---
/**
 * Garden Canvas Component
 *
 * Refactored to use Custom Elements for better encapsulation.
 */

export interface Props {
  width?: number;
  height?: number;
}

const {
  width = 1920,
  height = 1080,
} = Astro.props;
---

<garden-canvas data-width={width} data-height={height} class="block h-full w-full overflow-hidden">
  <canvas
    class="h-full w-full cursor-crosshair transition-opacity duration-1000"
  ></canvas>
</garden-canvas>

<script>
  import type { Entity, GardenState, SimulationEvent } from '../env.d.ts';
  import {
    createBackgroundAnimationState,
    resizeBackgroundAnimationState,
    syncBackgroundEventEffects,
    syncWeatherParticlesToBackgroundState,
    updateBackgroundAnimationState,
    type BackgroundAnimationState,
  } from '../lib/garden-canvas/background-effects/state.ts';
  import { renderBackgroundPass } from '../lib/garden-canvas/background-effects/renderer.ts';
  import type { BackgroundPass, BackgroundWorldState, ViewportSize } from '../lib/garden-canvas/background-effects/types.ts';
  import { GardenEntityRenderer } from '../lib/garden-canvas/entity-rendering/renderer.ts';
  import { createLightingContext, getTimePhaseFromSunlight } from '../lib/rendering/lighting.ts';
  import { AdaptiveQualityController } from '../lib/rendering/performance.ts';
  import type { LightingContext, QualityTier, TimePhase } from '../lib/rendering/types.ts';

  const COLORS = {
    plant: { h: 135, s: 40, l: 40 },
    herbivore: { h: 42, s: 60, l: 55 },
    carnivore: { h: 12, s: 50, l: 45 },
    fungus: { h: 280, s: 20, l: 65 },
  };

  const RENDER_PASSES: BackgroundPass[] = [
    'farBackground',
    'terrain',
    'ambientAtmosphere',
    'entityShadows',
    'entitiesBase',
    'entityOverlays',
    'foregroundParticles',
    'postLightVeil',
  ];

  class GardenCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private entities: Entity[] = [];
    private selectedEntity: Entity | null = null;
    private hoveredEntity: Entity | null = null;
    private gardenState: GardenState | null = null;
    private recentEvents: SimulationEvent[] = [];
    private mousePos = { x: 0, y: 0 };
    private targetMousePos = { x: 0, y: 0 };
    private animationId: number | null = null;
    private simWidth = 800;
    private simHeight = 600;
    private backgroundState: BackgroundAnimationState;
    private entityRenderer = new GardenEntityRenderer();
    private qualityController = new AdaptiveQualityController();
    private qualityTier: QualityTier = 'high';
    private lighting: LightingContext = createLightingContext(0.5, 0);
    private timePhase: TimePhase = 'day';
    private worldState: BackgroundWorldState = {
      tick: 0,
      temperature: 20,
      moisture: 0.5,
      sunlight: 0.5,
      totalLiving: 0,
      totalEntities: 0,
    };
    private frameStartTime = performance.now();

    private readonly handleWindowResize = () => this.handleResize();

    constructor() {
      super();
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d');
      this.backgroundState = createBackgroundAnimationState(this.getViewportSize(), this.qualityTier);
      this.handleResize();
    }

    connectedCallback() {
      this.setupEventListeners();

      setTimeout(() => {
        this.handleResize();
        this.startAnimation();
      }, 0);
    }

    disconnectedCallback() {
      if (this.animationId) cancelAnimationFrame(this.animationId);
      this.removeEventListeners();
    }

    private setupEventListeners() {
      window.addEventListener('resize', this.handleWindowResize);
      this.canvas.addEventListener('mousemove', this.handleMouseMove);
      this.canvas.addEventListener('mouseleave', this.handleMouseLeave);
      this.canvas.addEventListener('click', this.handleCanvasClick);
    }

    private removeEventListeners() {
      window.removeEventListener('resize', this.handleWindowResize);
      this.canvas.removeEventListener('mousemove', this.handleMouseMove);
      this.canvas.removeEventListener('mouseleave', this.handleMouseLeave);
      this.canvas.removeEventListener('click', this.handleCanvasClick);
    }

    private readonly handleMouseMove = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      this.targetMousePos.x = event.clientX - rect.left;
      this.targetMousePos.y = event.clientY - rect.top;

      const worldPos = this.screenToWorld(this.targetMousePos.x, this.targetMousePos.y);
      this.hoveredEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);
    };

    private readonly handleMouseLeave = () => {
      this.hoveredEntity = null;
    };

    private readonly handleCanvasClick = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const worldPos = this.screenToWorld(x, y);
      const clickedEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);

      this.dispatchEvent(new CustomEvent('entity-selected', {
        detail: clickedEntity,
        bubbles: true,
      }));
    };

    private handleResize() {
      const dpr = window.devicePixelRatio || 1;
      const viewport = this.getViewportSize();

      this.canvas.width = viewport.width * dpr;
      this.canvas.height = viewport.height * dpr;

      if (this.ctx) {
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      resizeBackgroundAnimationState(this.backgroundState, viewport, this.qualityTier);
    }

    private getViewportSize(): ViewportSize {
      const rect = this.getBoundingClientRect();
      return {
        width: rect.width || window.innerWidth,
        height: rect.height || window.innerHeight,
      };
    }

    private worldToScreen(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: x * scale + offsetX,
        y: y * scale + offsetY,
        scale,
      };
    }

    private screenToWorld(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: (x - offsetX) / scale,
        y: (y - offsetY) / scale,
      };
    }

    private findEntityAtPosition(x: number, y: number): Entity | null {
      for (const entity of this.entities) {
        const radius = this.calculateEntitySize(entity.energy) + 5;
        const distance = Math.sqrt(
          Math.pow(x - entity.position.x, 2) +
          Math.pow(y - entity.position.y, 2),
        );

        if (distance <= radius) return entity;
      }
      return null;
    }

    private calculateEntitySize(energy: number): number {
      return 4 + (energy / 20);
    }

    public updateState(
      entities: Entity[],
      selectedEntity: Entity | null,
      gardenState?: GardenState | null,
      recentEvents?: SimulationEvent[],
    ) {
      this.entities = entities;
      this.selectedEntity = selectedEntity;
      this.gardenState = gardenState ?? this.gardenState;
      this.recentEvents = recentEvents ?? this.recentEvents;

      if (this.recentEvents.length > 0) {
        syncBackgroundEventEffects(this.backgroundState, this.recentEvents, this.getViewportSize());
      }
    }

    public getEntityCanvasPosition(entity: Entity) {
      return this.worldToScreen(entity.position.x, entity.position.y);
    }

    private startAnimation() {
      const loop = () => {
        this.update();
        this.render();

        const frameEnd = performance.now();
        this.qualityTier = this.qualityController.recordFrame(frameEnd - this.frameStartTime);
        this.frameStartTime = frameEnd;

        this.animationId = requestAnimationFrame(loop);
      };
      this.animationId = requestAnimationFrame(loop);
    }

    private update() {
      const viewport = this.getViewportSize();
      const sunlight = this.gardenState?.environment.sunlight ?? 0.5;
      const tick = this.gardenState?.tick ?? 0;
      const temperature = this.gardenState?.environment.temperature ?? 20;
      const moisture = this.gardenState?.environment.moisture ?? 0.5;
      const totalLiving = this.gardenState?.populationSummary.totalLiving ?? this.entities.filter((entity) => entity.isAlive).length;
      const totalEntities = this.gardenState?.populationSummary.total ?? this.entities.length;
      const livingPlants = this.gardenState?.populationSummary.plants ?? this.entities.filter((entity) => entity.isAlive && entity.type === 'plant').length;
      const livingFungi = this.gardenState?.populationSummary.fungi ?? this.entities.filter((entity) => entity.isAlive && entity.type === 'fungus').length;
      const livingCarnivores = this.gardenState?.populationSummary.carnivores ?? this.entities.filter((entity) => entity.isAlive && entity.type === 'carnivore').length;
      const livingHerbivores = this.gardenState?.populationSummary.herbivores ?? this.entities.filter((entity) => entity.isAlive && entity.type === 'herbivore').length;
      const plantDensity = totalLiving > 0 ? livingPlants / totalLiving : 0;
      const fungusDensity = totalLiving > 0 ? livingFungi / totalLiving : 0;
      const predatorPressure = totalLiving > 0 ? livingCarnivores / totalLiving : 0;
      const activeCategories = [livingPlants, livingFungi, livingHerbivores, livingCarnivores].filter((count) => count > 0).length;
      const diversityIndex = activeCategories / 4;
      const eventIntensity = Math.min(1, (this.recentEvents?.length ?? 0) / 8);

      const weatherStateName = this.gardenState?.environment.weatherState?.currentState;
      const weatherTransitionProgress = this.gardenState?.environment.weatherState?.transitionProgressTicks ?? 0;

      this.lighting = createLightingContext(sunlight, tick, weatherStateName);
      this.timePhase = getTimePhaseFromSunlight(sunlight);
      this.worldState = {
        tick,
        temperature,
        moisture,
        sunlight,
        totalLiving,
        totalEntities,
        plantDensity,
        fungusDensity,
        predatorPressure,
        diversityIndex,
        eventIntensity,
        weatherStateName,
        weatherTransitionProgress,
      };

      syncWeatherParticlesToBackgroundState(
        this.backgroundState,
        weatherStateName ?? null,
        viewport,
      );

      updateBackgroundAnimationState(
        this.backgroundState,
        viewport,
        this.mousePos,
        this.targetMousePos,
        Date.now(),
        this.qualityTier,
      );
    }

    private render() {
      if (!this.ctx) return;

      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const frameTimestampMs = performance.now();
      this.ctx.clearRect(0, 0, width, height);

      const entityConfig = {
        selectedEntity: this.selectedEntity,
        hoveredEntity: this.hoveredEntity,
        worldToScreen: this.worldToScreen.bind(this),
        calculateEntitySize: this.calculateEntitySize.bind(this),
        colors: COLORS,
        lighting: this.lighting,
        qualityTier: this.qualityTier,
        timePhase: this.timePhase,
        frameTimestampMs,
      };

      RENDER_PASSES.forEach((pass) => {
        if (pass === 'entityShadows') {
          this.entityRenderer.renderEntityShadows(this.ctx!, this.entities, entityConfig);
          return;
        }

        if (pass === 'entitiesBase') {
          this.entityRenderer.renderEntitiesBase(this.ctx!, this.entities, entityConfig);
          return;
        }

        if (pass === 'entityOverlays') {
          this.entityRenderer.renderEntityOverlays(this.ctx!, this.entities, entityConfig);
          return;
        }

        renderBackgroundPass({
          ctx: this.ctx!,
          pass,
          viewport: { width, height },
          mousePos: this.mousePos,
          spores: this.backgroundState.spores,
          shadows: this.backgroundState.shadows,
          glitchSparks: this.backgroundState.glitchSparks,
          ripples: this.backgroundState.ripples,
          memoryRings: this.backgroundState.memoryRings,
          biomeCells: this.backgroundState.biomeCells,
          rootPressureCells: this.backgroundState.rootPressureCells,
          parallaxBands: this.backgroundState.parallaxBands,
          canopyNodes: this.backgroundState.canopyNodes,
          canopyEdges: this.backgroundState.canopyEdges,
          rainDrops: this.backgroundState.rainDrops,
          fogPatches: this.backgroundState.fogPatches,
          biomeDriftX: this.backgroundState.biomeDriftX,
          biomeDriftY: this.backgroundState.biomeDriftY,
          lighting: this.lighting,
          qualityTier: this.qualityTier,
          timePhase: this.timePhase,
          worldState: this.worldState,
        });
      });
    }
  }

  if (!customElements.get('garden-canvas')) {
    customElements.define('garden-canvas', GardenCanvas);
  }
</script>
