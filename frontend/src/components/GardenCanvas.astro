---
/**
 * Garden Canvas Component
 * 
 * Refactored to use Custom Elements for better encapsulation.
 */

export interface Props {
  width?: number;
  height?: number;
}

const {
  width = 1920,
  height = 1080
} = Astro.props;
---

<garden-canvas data-width={width} data-height={height} class="block h-full w-full overflow-hidden">
  <canvas 
    class="h-full w-full cursor-crosshair transition-opacity duration-1000"
  ></canvas>
</garden-canvas>

<script>
  import type { Entity } from '../env.d.ts';

  const COLORS = {
    plant: { h: 135, s: 40, l: 40 },      // Mossy Sage
    herbivore: { h: 42, s: 60, l: 55 },    // Lichen Amber
    carnivore: { h: 12, s: 50, l: 45 },    // Earthy Rust
    fungus: { h: 280, s: 20, l: 65 }       // Pale Mushroom
  };

  class GardenCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private entities: Entity[] = [];
    private selectedEntity: Entity | null = null;
    private mousePos = { x: 0, y: 0 };
    private targetMousePos = { x: 0, y: 0 };
    private animationId: number | null = null;
    private simWidth = 800;
    private simHeight = 600;
    private spores: Array<{ x: number, y: number, vx: number, vy: number, size: number, opacity: number }> = [];
    private shadows: Array<{ x: number, y: number, vx: number, vy: number, size: number, opacity: number }> = [];
    private glitchSparks: Array<{ x: number, y: number, opacity: number, size: number, lifetime: number, color: string, shape: number }> = [];
    private lastGlitchTime: number = 0;

    constructor() {
      super();
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d');
      
      this.setupEventListeners();
      this.handleResize();
    }

    connectedCallback() {
      // Force initialization on connect to ensure rect is available
      setTimeout(() => {
        this.handleResize();
        this.startAnimation();
      }, 0);
    }

    disconnectedCallback() {
      if (this.animationId) cancelAnimationFrame(this.animationId);
    }

    private setupEventListeners() {
      window.addEventListener('resize', () => this.handleResize());
      
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.targetMousePos.x = e.clientX - rect.left;
        this.targetMousePos.y = e.clientY - rect.top;
      });

      this.canvas.addEventListener('click', (event) => this.handleCanvasClick(event));
    }

    private handleResize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      if (this.ctx) this.ctx.scale(dpr, dpr);
      this.initSpores();
      this.initShadows();
    }

    /**
     * VISUAL EFFECT #1: Dappled Canopy Shadows
     * 
     * Simulates large, soft shadows drifting across the forest floor as if wind
     * is moving through a canopy of trees above. Creates a sense of dynamic lighting
     * and adds depth to the garden atmosphere.
     * 
     * Parameters:
     * - Count: 8 shadow blobs
     * - Size: 400-800px diameter (large, organic shapes)
     * - Opacity: 12-27% (visible but not overwhelming)
     * - Velocity: 0.06-0.12 px/frame (slow, natural drift)
     * - Color: Dark forest green (rgba(0, 15, 5))
     */
    private initShadows() {
      const rect = this.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      this.shadows = Array.from({ length: 8 }, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0.06 + Math.random() * 0.06,
        vy: 0.06 + Math.random() * 0.06,
        size: 400 + Math.random() * 400,
        opacity: 0.12 + Math.random() * 0.15
      }));
    }

    /**
     * VISUAL EFFECT #4: Floating Spores
     * 
     * Simulates gentle floating spores drifting through the air, creating a
     * mystical and ethereal atmosphere. These represent fungal reproduction
     * and contribute to the garden's organic, living feel.
     * 
     * Parameters:
     * - Count: 60 spores (balanced density)
     * - Size: 0.6-2.0 pixels (tiny, barely visible)
     * - Opacity: 8-23% (subtle but noticeable)
     * - Velocity: Â±0.06 px/frame (slow, random drift)
     * - Color: Pale green-yellow (rgba(220, 240, 160))
     * - Glow: 5x size radial gradient (soft, diffused)
     */
    private initSpores() {
      const rect = this.getBoundingClientRect();
      // Ensure we have a valid width/height before initializing
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      
      this.spores = Array.from({ length: 60 }, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 0.12,
        vy: (Math.random() - 0.5) * 0.12,
        size: Math.random() * 1.4 + 0.6,
        opacity: Math.random() * 0.15 + 0.08 // Balanced visibility
      }));
    }

    private handleCanvasClick(event: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const worldPos = this.screenToWorld(x, y);
      const clickedEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);
      
      this.dispatchEvent(new CustomEvent('entity-selected', {
        detail: clickedEntity,
        bubbles: true
      }));
    }

    private worldToScreen(x: number, y: number) {
      const scale = Math.min(this.canvas.clientWidth / this.simWidth, this.canvas.clientHeight / this.simHeight) * 0.9;
      const offsetX = (this.canvas.clientWidth - this.simWidth * scale) / 2;
      const offsetY = (this.canvas.clientHeight - this.simHeight * scale) / 2;
      return {
        x: x * scale + offsetX,
        y: y * scale + offsetY,
        scale
      };
    }

    private screenToWorld(x: number, y: number) {
      const scale = Math.min(this.canvas.clientWidth / this.simWidth, this.canvas.clientHeight / this.simHeight) * 0.9;
      const offsetX = (this.canvas.clientWidth - this.simWidth * scale) / 2;
      const offsetY = (this.canvas.clientHeight - this.simHeight * scale) / 2;
      return {
        x: (x - offsetX) / scale,
        y: (y - offsetY) / scale
      };
    }

    private findEntityAtPosition(x: number, y: number): Entity | null {
      for (const entity of this.entities) {
        const radius = this.calculateEntitySize(entity.energy) + 5;
        const distance = Math.sqrt(
          Math.pow(x - entity.position.x, 2) + 
          Math.pow(y - entity.position.y, 2)
        );
        
        if (distance <= radius) return entity;
      }
      return null;
    }

    private calculateEntitySize(energy: number): number {
      return 4 + (energy / 20);
    }

    public updateState(entities: Entity[], selectedEntity: Entity | null) {
      this.entities = entities;
      this.selectedEntity = selectedEntity;
    }

    public getEntityCanvasPosition(entity: Entity) {
      return this.worldToScreen(entity.position.x, entity.position.y);
    }

    private startAnimation() {
      const loop = () => {
        this.update();
        this.render();
        this.animationId = requestAnimationFrame(loop);
      };
      this.animationId = requestAnimationFrame(loop);
    }

    private update() {
      // Smooth mouse follow for parallax/bloom effects
      this.mousePos.x += (this.targetMousePos.x - this.mousePos.x) * 0.05;
      this.mousePos.y += (this.targetMousePos.y - this.mousePos.y) * 0.05;

      const rect = this.getBoundingClientRect();
      this.spores.forEach(s => {
        s.x += s.vx;
        s.y += s.vy;
        if (s.x < 0) s.x = rect.width;
        if (s.x > rect.width) s.x = 0;
        if (s.y < 0) s.y = rect.height;
        if (s.y > rect.height) s.y = 0;
      });

      // Update Canopy Shadows - drift across canvas, wrap at edges
      this.shadows.forEach(s => {
        s.x += s.vx;
        s.y += s.vy;
        if (s.x > rect.width + s.size) s.x = -s.size;
        if (s.y > rect.height + s.size) s.y = -s.size;
      });

      /**
       * VISUAL EFFECT #3: Mycelial "Glitch" Sparks
       * 
       * Random colorful energy bursts that simulate hidden activity in the
       * underground fungal network. Creates playful, unexpected moments of
       * visual interest distinct from the floating spores.
       * 
       * Timing: 2-8 seconds between sparks (3x more frequent than original)
       * Colors: Magenta, Cyan, Violet, Gold, Electric Blue, Lime
       * Shapes: Circle or Square (random)
       * Size: 2-14 pixels with 2.5x glow radius
       * Lifetime: 180ms fade
       */
      const now = Date.now();
      if (now - this.lastGlitchTime > 2000 + Math.random() * 6000) {
        this.addGlitchSpark(rect.width, rect.height);
        this.lastGlitchTime = now;
      }

      // Update Glitch Sparks - fade out over lifetime
      this.glitchSparks = this.glitchSparks.filter(s => s.lifetime > 0);
      this.glitchSparks.forEach(s => {
        s.lifetime -= 16; // ~60fps
        s.opacity = s.lifetime / 200; // fade over 200ms
      });
    }

    private addGlitchSpark(width: number, height: number) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      // Distinct color palette (different from spores)
      const colorChoices = [
        '255, 100, 180', // Magenta
        '100, 220, 255', // Cyan
        '180, 120, 255', // Violet
        '255, 200, 100', // Gold
        '100, 180, 255', // Electric Blue
        '220, 255, 100'  // Lime
      ];
      const color = colorChoices[Math.floor(Math.random() * colorChoices.length)];
      const shape = Math.floor(Math.random() * 2); // 0=circle, 1=square
      this.glitchSparks.push({
        x,
        y,
        opacity: 1,
        size: 2 + Math.random() * 12, // 2-14 pixels
        lifetime: 180,
        color,
        shape
      });
    }

    private render() {
      if (!this.ctx) return;
      const { width, height } = this.canvas.getBoundingClientRect();
      this.ctx.clearRect(0, 0, width, height);

      this.drawAura(width, height);
      this.drawAtmosphere(width, height);
      this.drawShadows();
      this.drawSpores();
      this.drawGlitchSparks();

      this.entities.forEach(entity => this.drawEntity(entity));
    }

    /**
     * VISUAL EFFECT #3: Draw Mycelial "Glitch" Sparks
     * 
     * Renders each active spark with its assigned color, shape, and glow.
     * Sparks are visually distinct from spores through vibrant colors and
     * geometric variety.
     * 
     * Rendering:
     * - Outer Glow: 2.5x size, 30% opacity, color-matched
     * - Core Shape: 0.5x size, 70% opacity, shape-specific geometry
     * - Shapes: Circle (0), Square (1)
     */
    private drawGlitchSparks() {
      if (!this.ctx) return;
      this.glitchSparks.forEach(s => {
        if (s.opacity <= 0) return;
        this.ctx!.save();
        
        // Use assigned random color (distinct from green-yellow spores)
        const baseColor = `rgba(${s.color}, ${s.opacity * 0.7})`;
        const glowColor = `rgba(${s.color}, ${s.opacity * 0.3})`;
        
        // Draw outer glow (radial gradient regardless of core shape)
        const grad = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 2.5);
        grad.addColorStop(0, glowColor);
        grad.addColorStop(1, 'transparent');
        this.ctx!.fillStyle = grad;
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size * 2.5, 0, Math.PI * 2);
        this.ctx!.fill();
        
        // Draw core shape (geometry based on assigned shape type)
        this.ctx!.fillStyle = baseColor;
        this.ctx!.beginPath();
        const halfSize = s.size * 0.5;
        if (s.shape === 1) { // Square
          this.ctx!.rect(s.x - halfSize, s.y - halfSize, s.size, s.size);
        } else { // Circle (default)
          this.ctx!.arc(s.x, s.y, halfSize, 0, Math.PI * 2);
        }
        this.ctx!.fill();
        this.ctx!.restore();
      });
    }

    /**
     * VISUAL EFFECT #1: Draw Dappled Canopy Shadows
     * 
     * Renders large, soft shadow blobs that drift across the canvas.
     * Each shadow is a radial gradient with dark forest green coloring,
     * creating the impression of overhead foliage shifting in the wind.
     */
    private drawShadows() {
      if (!this.ctx) return;
      this.shadows.forEach(s => {
        this.ctx!.save();
        const shadowGrad = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size);
        shadowGrad.addColorStop(0, `rgba(0, 15, 5, ${s.opacity})`); // Dark forest green
        shadowGrad.addColorStop(1, 'rgba(0, 15, 5, 0)');
        this.ctx!.fillStyle = shadowGrad;
        this.ctx!.fillRect(s.x - s.size, s.y - s.size, s.size * 2, s.size * 2);
        this.ctx!.restore();
      });
    }

    /**
     * VISUAL EFFECT #2: Ambient "Aura" Pulse (The Forest Breath)
     * 
     * Creates a slow, rhythmic "breathing" effect across the entire canvas,
     * making the digital ecosystem feel alive. A gentle green radial gradient
     * expands and contracts from the center, simulating the pulse of life itself.
     * 
     * Cycle: 6 seconds (sine wave oscillation)
     * Intensity: 8-23% alpha (noticeable but ambient)
     * Coverage: 80% of canvas width (radial)
     * Color: Forest green (rgba(34, 197, 94))
     */
    private drawAura(width: number, height: number) {
      if (!this.ctx) return;
      
      const time = Date.now() / 6000; // 6-second breathing cycle
      const pulse = (Math.sin(time) + 1) / 2; // Oscillate 0 to 1
      
      this.ctx.save();
      const auraGradient = this.ctx.createRadialGradient(
        width/2, height/2, 0,
        width/2, height/2, width * 0.8
      );
      // Modulate green intensity (8% to 23% alpha)
      auraGradient.addColorStop(0, `rgba(34, 197, 94, ${0.08 + pulse * 0.15})`);
      auraGradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
      
      this.ctx.fillStyle = auraGradient;
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.restore();
    }

    /**
     * VISUAL EFFECT #5: Atmospheric Elements
     * 
     * Creates a multi-layered atmospheric effect that enhances depth and immersion:
     * 
     * 1. **Parallax Background Network**: Subtle "root" or "vein" patterns that shift
     *    slightly with mouse movement, creating a sense of depth and grounding.
     * 
     * 2. **Warm Sunlight Dappling**: Radial gradient that follows the mouse cursor,
     *    simulating sunlight filtering through the canopy and dappling the forest floor.
     * 
     * Together, these elements create a dynamic, living atmosphere that responds
     * to user interaction.
     */
    private drawAtmosphere(width: number, height: number) {
      if (!this.ctx) return;

      // Parallax Background elements (Subtle "Roots" or "Veins")
      const px = (this.mousePos.x / width - 0.5) * 20;
      const py = (this.mousePos.y / height - 0.5) * 20;

      this.ctx.save();
      this.ctx.translate(px, py);
      this.ctx.strokeStyle = 'rgba(210, 230, 150, 0.02)';
      this.ctx.lineWidth = 1;
      
      // Draw very faint network pattern
      for (let i = 0; i < 5; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, height * 0.2 * i);
        this.ctx.bezierCurveTo(width * 0.3, height * 0.5, width * 0.7, height * 0.1, width, height * 0.8 * i);
        this.ctx.stroke();
      }
      this.ctx.restore();

      // Warm Sunlight Dappling (follows mouse smoothly)
      const gradient = this.ctx.createRadialGradient(
        this.mousePos.x, this.mousePos.y, 0,
        this.mousePos.x, this.mousePos.y, 500
      );
      gradient.addColorStop(0, 'rgba(210, 230, 150, 0.07)'); 
      gradient.addColorStop(1, 'rgba(210, 230, 150, 0)');
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, width, height);
    }

    /**
     * VISUAL EFFECT #4: Draw Floating Spores
     * 
     * Renders the floating spores with a soft, diffused glow effect. Each spore
     * has a tiny core with a larger radial glow, creating a mystical, ethereal appearance.
     * 
     * Rendering:
     * - Core Mote: 0.6-2.0px diameter, pale green-yellow
     * - Outer Glow: 5x size radial gradient, 40% opacity
     * - Opacity: 8-23% (subtle but noticeable)
     */
    private drawSpores() {
      if (!this.ctx) return;
      this.spores.forEach(s => {
        // Core Mote
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        this.ctx!.fillStyle = `rgba(220, 240, 160, ${s.opacity})`; // Slightly brighter
        this.ctx!.fill();
        
        // Balanced Spore Glow
        const glow = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 5);
        glow.addColorStop(0, `rgba(220, 240, 160, ${s.opacity * 0.4})`);
        glow.addColorStop(1, 'rgba(220, 240, 160, 0)');
        this.ctx!.fillStyle = glow;
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size * 5, 0, Math.PI * 2);
        this.ctx!.fill();
      });
    }

    /**
     * VISUAL EFFECT #6: Entity Rendering Effects
     * 
     * Renders garden entities with dynamic visual effects that communicate their
     * state and create visual interest:
     * 
     * 1. **Health Glow**: Entities with health > 50% emit a subtle glow
     * 2. **Dynamic Lighting**: Lighting intensity shifts based on mouse proximity
     * 3. **Sway Animation**: Gentle left-right swaying motion
     * 4. **Selection Ring**: Dashed border when entity is selected
     * 5. **Color Variation**: Hue shifts based on health, saturation decreases with damage
     * 
     * These effects make entities feel alive and responsive to both their environment
     * and user interaction.
     */
    private drawEntity(entity: Entity) {
      if (!this.ctx) return;
      const { type, position, energy, health } = entity;
      const isSelected = this.selectedEntity && this.selectedEntity.id === entity.id;
      const { x, y, scale } = this.worldToScreen(position.x, position.y);
      const radius = this.calculateEntitySize(energy) * scale;
      const color = COLORS[type as keyof typeof COLORS] || COLORS.plant;
      
      const time = Date.now() / 1000;
      const sway = Math.sin(time + position.x) * 2;
      const healthFactor = health / 100;

      // Glow Layer - Healthy entities emit subtle glow
      if (health > 50) {
        this.ctx.beginPath();
        this.ctx.arc(x + sway, y, radius * 2.5, 0, Math.PI * 2);
        const glow = this.ctx.createRadialGradient(x + sway, y, 0, x + sway, y, radius * 2.5);
        glow.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${0.1 * healthFactor})`);
        glow.addColorStop(1, 'transparent');
        this.ctx.fillStyle = glow;
        this.ctx.fill();
      }

      // Core Body - Dynamic color based on health and lighting
      this.ctx.beginPath();
      this.ctx.arc(x + sway, y, radius, 0, Math.PI * 2);
      
      // Dynamic Lighting based on mouse proximity
      const dx = this.mousePos.x - x;
      const dy = this.mousePos.y - y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const lightIntense = Math.max(0, 1 - dist / 400);

      this.ctx.fillStyle = `hsla(${color.h}, ${color.s - (1-healthFactor)*30}%, ${color.l + lightIntense * 15}%, ${0.7 + lightIntense * 0.3})`;
      this.ctx.fill();

      // Selection Ring - Dashed border for selected entities
      if (isSelected) {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([2, 2]);
        this.ctx.beginPath();
        this.ctx.arc(x + sway, y, radius + 6, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
      }
    }
  }

  customElements.define('garden-canvas', GardenCanvas);
</script>
