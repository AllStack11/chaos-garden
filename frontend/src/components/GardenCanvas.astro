---
/**
 * Garden Canvas Component
 * 
 * Refactored to use Custom Elements for better encapsulation.
 */

export interface Props {
  width?: number;
  height?: number;
}

const {
  width = 800,
  height = 600
} = Astro.props;
---

<garden-canvas data-width={width} data-height={height}>
  <div class="relative">
    <canvas 
      width={width}
      height={height}
      class="w-full h-auto rounded-xl border-2 border-garden-brown-300 shadow-lg bg-gradient-to-b from-garden-green-50 to-garden-green-100"
    ></canvas>
    
    <!-- Overlay instructions -->
    <div class="absolute top-4 left-4 bg-white/80 backdrop-blur-sm rounded-lg p-3 text-sm pointer-events-none">
      <div class="flex items-center space-x-2">
        <span class="text-garden-green-600 font-medium">Canvas Controls:</span>
        <span class="text-garden-brown-600">Click entities to select</span>
      </div>
    </div>
    
    <!-- Legend -->
    <div class="absolute bottom-4 left-4 bg-white/80 backdrop-blur-sm rounded-lg p-3 text-sm pointer-events-none">
      <div class="grid grid-cols-2 gap-2">
        <div class="flex items-center space-x-2">
          <div class="w-3 h-3 rounded-full bg-green-500"></div>
          <span class="text-garden-brown-700">Plants</span>
        </div>
        <div class="flex items-center space-x-2">
          <div class="w-3 h-3 rounded-full bg-yellow-500"></div>
          <span class="text-garden-brown-700">Herbivores</span>
        </div>
      </div>
    </div>
  </div>
</garden-canvas>

<script>
  import type { Entity } from '../env.d.ts';

  const ENTITY_COLORS = {
    plant: {
      fill: '#22c55e',
      stroke: '#15803d',
      selected: '#16a34a'
    },
    herbivore: {
      fill: '#f59e0b',
      stroke: '#d97706',
      selected: '#eab308'
    },
    carnivore: {
      fill: '#ef4444',
      stroke: '#b91c1c',
      selected: '#dc2626'
    },
    fungus: {
      fill: '#8b5cf6',
      stroke: '#7c3aed',
      selected: '#7c3aed'
    }
  };

  class GardenCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private entities: Entity[] = [];
    private selectedEntity: Entity | null = null;

    constructor() {
      super();
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d');
      
      this.setupEventListeners();
    }

    private setupEventListeners() {
      this.canvas.addEventListener('click', (event) => this.handleCanvasClick(event));
    }

    private handleCanvasClick(event: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const scaleX = this.canvas.width / rect.width;
      const scaleY = this.canvas.height / rect.height;
      const canvasX = x * scaleX;
      const canvasY = y * scaleY;
      
      const clickedEntity = this.findEntityAtPosition(canvasX, canvasY);
      
      this.dispatchEvent(new CustomEvent('entity-selected', {
        detail: clickedEntity,
        bubbles: true
      }));
    }

    private findEntityAtPosition(x: number, y: number): Entity | null {
      for (const entity of this.entities) {
        const radius = this.calculateEntitySize(entity.energy);
        const distance = Math.sqrt(
          Math.pow(x - entity.position.x, 2) + 
          Math.pow(y - entity.position.y, 2)
        );
        
        if (distance <= radius) return entity;
      }
      return null;
    }

    private calculateEntitySize(energy: number): number {
      const baseSize = 8;
      const energyMultiplier = Math.max(0.5, energy / 50);
      return baseSize * energyMultiplier;
    }

    public updateState(entities: Entity[], selectedEntity: Entity | null) {
      this.entities = entities;
      this.selectedEntity = selectedEntity;
      this.render();
    }

    private render() {
      if (!this.ctx) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.drawGrid();
      this.entities.forEach(entity => this.drawEntity(entity));
      if (this.selectedEntity) this.drawSelection(this.selectedEntity);
    }

    private drawGrid() {
      if (!this.ctx) return;
      this.ctx.strokeStyle = 'rgba(139, 92, 246, 0.05)';
      this.ctx.lineWidth = 0.5;
      for (let x = 0; x <= this.canvas.width; x += 50) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, 0);
        this.ctx.lineTo(x, this.canvas.height);
        this.ctx.stroke();
      }
      for (let y = 0; y <= this.canvas.height; y += 50) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(this.canvas.width, y);
        this.ctx.stroke();
      }
    }

    private drawEntity(entity: Entity) {
      if (!this.ctx) return;
      const { type, position, energy, health } = entity;
      const colors = ENTITY_COLORS[type as keyof typeof ENTITY_COLORS] || ENTITY_COLORS.plant;
      const isSelected = this.selectedEntity && this.selectedEntity.id === entity.id;
      const radius = this.calculateEntitySize(energy);
      const { x, y } = position;

      this.ctx.beginPath();
      this.ctx.arc(x, y, radius, 0, Math.PI * 2);
      this.ctx.fillStyle = isSelected ? colors.selected : colors.fill;
      this.ctx.fill();
      this.ctx.strokeStyle = colors.stroke;
      this.ctx.lineWidth = Math.max(1, health / 25);
      this.ctx.stroke();

      if (isSelected) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
        this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      }
    }

    private drawSelection(entity: Entity) {
      if (!this.ctx) return;
      const { position } = entity;
      const radius = this.calculateEntitySize(entity.energy) + 8;
      const time = Date.now() / 1000;
      const pulse = (Math.sin(time * 3) + 1) / 2;

      this.ctx.beginPath();
      this.ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
      this.ctx.strokeStyle = `rgba(59, 130, 246, ${0.3 + pulse * 0.4})`;
      this.ctx.lineWidth = 3;
      this.ctx.stroke();
      
      // Request animation frame for pulsing effect if something is selected
      requestAnimationFrame(() => this.render());
    }
  }

  customElements.define('garden-canvas', GardenCanvas);
</script>
