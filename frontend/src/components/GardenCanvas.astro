---
/**
 * Garden Canvas Component
 * 
 * Refactored to use Custom Elements for better encapsulation.
 */

export interface Props {
  width?: number;
  height?: number;
}

const {
  width = 1920,
  height = 1080
} = Astro.props;
---

<garden-canvas data-width={width} data-height={height} class="block h-full w-full overflow-hidden">
  <canvas 
    class="h-full w-full cursor-crosshair transition-opacity duration-1000"
  ></canvas>
</garden-canvas>

<script>
  import type { Entity } from '../env.d.ts';
  import { PlantRenderer } from '../lib/rendering/entities/PlantRenderer.ts';
  import { getPlantVisual } from '../lib/rendering/PlantVisualSystem.ts';
  import { HerbivoreRenderer } from '../lib/rendering/entities/HerbivoreRenderer.ts';
  import { getHerbivoreVisual } from '../lib/rendering/HerbivoreVisualSystem.ts';

  const COLORS = {
    plant: { h: 135, s: 40, l: 40 },      // Mossy Sage
    herbivore: { h: 42, s: 60, l: 55 },    // Lichen Amber
    carnivore: { h: 12, s: 50, l: 45 },    // Earthy Rust
    fungus: { h: 280, s: 20, l: 65 }       // Pale Mushroom
  };

  class GardenCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private entities: Entity[] = [];
    private selectedEntity: Entity | null = null;
    private hoveredEntity: Entity | null = null;
    private mousePos = { x: 0, y: 0 };
    private targetMousePos = { x: 0, y: 0 };
    private animationId: number | null = null;
    private simWidth = 800;
    private simHeight = 600;
    private spores: Array<{ x: number, y: number, vx: number, vy: number, size: number, opacity: number }> = [];
    private shadows: Array<{ x: number, y: number, vx: number, vy: number, size: number, opacity: number }> = [];
    private glitchSparks: Array<{ x: number, y: number, opacity: number, size: number, lifetime: number, color: string, shape: number }> = [];
    private lastGlitchTime: number = 0;

    constructor() {
      super();
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d');
      
      this.setupEventListeners();
      this.handleResize();
    }

    connectedCallback() {
      setTimeout(() => {
        this.handleResize();
        this.startAnimation();
      }, 0);
    }

    disconnectedCallback() {
      if (this.animationId) cancelAnimationFrame(this.animationId);
    }

    private setupEventListeners() {
      window.addEventListener('resize', () => this.handleResize());
      
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.targetMousePos.x = e.clientX - rect.left;
        this.targetMousePos.y = e.clientY - rect.top;
        
        // Track hovered entity
        const worldPos = this.screenToWorld(this.targetMousePos.x, this.targetMousePos.y);
        this.hoveredEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);
      });

      this.canvas.addEventListener('mouseleave', () => {
        this.hoveredEntity = null;
      });

      this.canvas.addEventListener('click', (event) => this.handleCanvasClick(event));
    }

    private handleResize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      this.canvas.width = width * dpr;
      this.canvas.height = height * dpr;
      if (this.ctx) {
        this.ctx.scale(dpr, dpr);
      }
      this.initSpores();
      this.initShadows();
    }

    private initShadows() {
      const rect = this.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      this.shadows = Array.from({ length: 8 }, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0.06 + Math.random() * 0.06,
        vy: 0.06 + Math.random() * 0.06,
        size: 400 + Math.random() * 400,
        opacity: 0.12 + Math.random() * 0.15
      }));
    }

    private initSpores() {
      const rect = this.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      
      this.spores = Array.from({ length: 60 }, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 0.12,
        vy: (Math.random() - 0.5) * 0.12,
        size: Math.random() * 1.4 + 0.6,
        opacity: Math.random() * 0.15 + 0.08
      }));
    }

    private handleCanvasClick(event: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      const worldPos = this.screenToWorld(x, y);
      const clickedEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);
      
      this.dispatchEvent(new CustomEvent('entity-selected', {
        detail: clickedEntity,
        bubbles: true
      }));
    }

    private worldToScreen(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: x * scale + offsetX,
        y: y * scale + offsetY,
        scale
      };
    }

    private screenToWorld(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: (x - offsetX) / scale,
        y: (y - offsetY) / scale
      };
    }

    private findEntityAtPosition(x: number, y: number): Entity | null {
      for (const entity of this.entities) {
        const radius = this.calculateEntitySize(entity.energy) + 5;
        const distance = Math.sqrt(
          Math.pow(x - entity.position.x, 2) + 
          Math.pow(y - entity.position.y, 2)
        );
        
        if (distance <= radius) return entity;
      }
      return null;
    }

    private calculateEntitySize(energy: number): number {
      return 4 + (energy / 20);
    }

    public updateState(entities: Entity[], selectedEntity: Entity | null) {
      this.entities = entities;
      this.selectedEntity = selectedEntity;
    }

    public getEntityCanvasPosition(entity: Entity) {
      return this.worldToScreen(entity.position.x, entity.position.y);
    }

    private startAnimation() {
      const loop = () => {
        this.update();
        this.render();
        this.animationId = requestAnimationFrame(loop);
      };
      this.animationId = requestAnimationFrame(loop);
    }

    private update() {
      this.mousePos.x += (this.targetMousePos.x - this.mousePos.x) * 0.05;
      this.mousePos.y += (this.targetMousePos.y - this.mousePos.y) * 0.05;

      const rect = this.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;

      this.spores.forEach(s => {
        s.x += s.vx;
        s.y += s.vy;
        if (s.x < 0) s.x = width;
        if (s.x > width) s.x = 0;
        if (s.y < 0) s.y = height;
        if (s.y > height) s.y = 0;
      });

      this.shadows.forEach(s => {
        s.x += s.vx;
        s.y += s.vy;
        if (s.x > width + s.size) s.x = -s.size;
        if (s.y > height + s.size) s.y = -s.size;
      });

      const now = Date.now();
      if (now - this.lastGlitchTime > 2000 + Math.random() * 6000) {
        this.addGlitchSpark(width, height);
        this.lastGlitchTime = now;
      }

      this.glitchSparks = this.glitchSparks.filter(s => s.lifetime > 0);
      this.glitchSparks.forEach(s => {
        s.lifetime -= 16;
        s.opacity = s.lifetime / 200;
      });
    }

    private addGlitchSpark(width: number, height: number) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const colorChoices = ['255, 100, 180', '100, 220, 255', '180, 120, 255', '255, 200, 100', '100, 180, 255', '220, 255, 100'];
      const color = colorChoices[Math.floor(Math.random() * colorChoices.length)];
      const shape = Math.floor(Math.random() * 2);
      this.glitchSparks.push({ x, y, opacity: 1, size: 2 + Math.random() * 12, lifetime: 180, color, shape });
    }

    private render() {
      if (!this.ctx) return;
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      this.ctx.clearRect(0, 0, width, height);

      this.drawAura(width, height);
      this.drawAtmosphere(width, height);
      this.drawShadows();
      this.drawSpores();
      this.drawGlitchSparks();

      const sortedEntities = [...this.entities].sort((a, b) => a.position.y - b.position.y);
      sortedEntities.forEach(entity => this.drawEntity(entity));
    }

    private drawGlitchSparks() {
      if (!this.ctx) return;
      this.glitchSparks.forEach(s => {
        if (s.opacity <= 0) return;
        this.ctx!.save();
        const baseColor = `rgba(${s.color}, ${s.opacity * 0.7})`;
        const glowColor = `rgba(${s.color}, ${s.opacity * 0.3})`;
        const grad = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 2.5);
        grad.addColorStop(0, glowColor);
        grad.addColorStop(1, 'transparent');
        this.ctx!.fillStyle = grad;
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size * 2.5, 0, Math.PI * 2);
        this.ctx!.fill();
        this.ctx!.fillStyle = baseColor;
        this.ctx!.beginPath();
        const halfSize = s.size * 0.5;
        if (s.shape === 1) {
          this.ctx!.rect(s.x - halfSize, s.y - halfSize, s.size, s.size);
        } else {
          this.ctx!.arc(s.x, s.y, halfSize, 0, Math.PI * 2);
        }
        this.ctx!.fill();
        this.ctx!.restore();
      });
    }

    private drawShadows() {
      if (!this.ctx) return;
      this.shadows.forEach(s => {
        this.ctx!.save();
        const shadowGrad = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size);
        shadowGrad.addColorStop(0, `rgba(0, 15, 5, ${s.opacity})`);
        shadowGrad.addColorStop(1, 'rgba(0, 15, 5, 0)');
        this.ctx!.fillStyle = shadowGrad;
        this.ctx!.fillRect(s.x - s.size, s.y - s.size, s.size * 2, s.size * 2);
        this.ctx!.restore();
      });
    }

    private drawAura(width: number, height: number) {
      if (!this.ctx) return;
      const time = Date.now() / 6000;
      const pulse = (Math.sin(time) + 1) / 2;
      this.ctx.save();
      const auraGradient = this.ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.8);
      auraGradient.addColorStop(0, `rgba(34, 197, 94, ${0.08 + pulse * 0.15})`);
      auraGradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
      this.ctx.fillStyle = auraGradient;
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.restore();
    }

    private drawAtmosphere(width: number, height: number) {
      if (!this.ctx) return;
      const px = (this.mousePos.x / width - 0.5) * 20;
      const py = (this.mousePos.y / height - 0.5) * 20;
      this.ctx.save();
      this.ctx.translate(px, py);
      this.ctx.strokeStyle = 'rgba(210, 230, 150, 0.02)';
      this.ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, height * 0.2 * i);
        this.ctx.bezierCurveTo(width * 0.3, height * 0.5, width * 0.7, height * 0.1, width, height * 0.8 * i);
        this.ctx.stroke();
      }
      this.ctx.restore();
      const gradient = this.ctx.createRadialGradient(this.mousePos.x, this.mousePos.y, 0, this.mousePos.x, this.mousePos.y, 500);
      gradient.addColorStop(0, 'rgba(210, 230, 150, 0.07)');
      gradient.addColorStop(1, 'rgba(210, 230, 150, 0)');
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, width, height);
    }

    private drawSpores() {
      if (!this.ctx) return;
      this.spores.forEach(s => {
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        this.ctx!.fillStyle = `rgba(220, 240, 160, ${s.opacity})`;
        this.ctx!.fill();
        const glow = this.ctx!.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 5);
        glow.addColorStop(0, `rgba(220, 240, 160, ${s.opacity * 0.4})`);
        glow.addColorStop(1, 'rgba(220, 240, 160, 0)');
        this.ctx!.fillStyle = glow;
        this.ctx!.beginPath();
        this.ctx!.arc(s.x, s.y, s.size * 5, 0, Math.PI * 2);
        this.ctx!.fill();
      });
    }

    private drawEntity(entity: Entity) {
      if (!this.ctx) return;
      if (!entity.isAlive) return;
      const { type, position, energy, name } = entity;
      const isSelected = this.selectedEntity && this.selectedEntity.id === entity.id;
      const isHovered = this.hoveredEntity && this.hoveredEntity.id === entity.id;
      const { x, y, scale } = this.worldToScreen(position.x, position.y);
      const radius = this.calculateEntitySize(energy) * scale;
      const color = COLORS[type as keyof typeof COLORS] || COLORS.plant;
      const time = Date.now() / 1000;
      
      this.drawDetailedEntity(entity, x, y, scale, radius, color, time);
      
      // Show name only on hover
      if (isHovered) {
        this.drawNameTag(name, x, y - radius - 15, false);
      }
      
      if (isSelected) {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([4, 4]);
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius + 12, 0, Math.PI * 2);
        this.ctx.stroke();
      }
    }

    private drawDetailedEntity(entity: Entity, x: number, y: number, scale: number,      radius: number, color: { h: number; s: number; l: number }, time: number) {
      const healthFactor = entity.health / 100;
      const energyFactor = entity.energy / 100;
      const baseColor = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
      const healthColor = `hsl(${color.h}, ${color.s * healthFactor}%, ${color.l + (1 - healthFactor) * 20}%)`;
      
      switch (entity.type) {
        case 'plant':
          this.drawPlantEntity(entity, x, y, scale, radius, baseColor, healthColor, time, healthFactor, energyFactor);
          break;
        case 'herbivore':
          this.drawHerbivoreEntity(entity, x, y, scale, radius, baseColor, healthColor, time, healthFactor);
          break;
        case 'carnivore':
          this.drawCarnivoreEntity(x, y, scale, radius, healthColor, time, energyFactor);
          break;
        case 'fungus':
          this.drawFungusEntity(x, y, radius, baseColor, healthColor, time, healthFactor, energyFactor);
          break;
      }
    }

    private drawPlantEntity(entity: Entity, x: number, y: number, scale: number, radius: number, baseColor: string, healthColor: string, time: number, healthFactor: number, energyFactor: number) {
      if (!this.ctx) return;
      const plantRenderer = new PlantRenderer();
      const plantEntity = {
        ...entity,
        type: 'plant' as const,
        health: healthFactor * 100,
        energy: energyFactor * 100,
        position: { x, y },
        traits: {
          photosynthesisRate: (entity as any).photosynthesisRate ?? 1.0,
          reproductionRate: (entity as any).reproductionRate ?? 0.05,
          metabolismEfficiency: (entity as any).metabolismEfficiency ?? 1.0
        }
      };
      // @ts-ignore
      const visual = getPlantVisual(plantEntity);
      // @ts-ignore
      plantRenderer.render(this.ctx, plantEntity, visual, x, y, time);
    }

    private drawHerbivoreEntity(entity: Entity, x: number, y: number, scale: number, radius: number, baseColor: string, healthColor: string, time: number, healthFactor: number) {
      if (!this.ctx) return;
      const herbivoreRenderer = new HerbivoreRenderer();
      const herbivoreEntity = {
        ...entity,
        type: 'herbivore' as const,
        health: healthFactor * 100,
        energy: radius * 2,
        position: { x, y },
        traits: {
          reproductionRate: (entity as any).reproductionRate ?? 0.03,
          movementSpeed: (entity as any).movementSpeed ?? 2.0,
          metabolismEfficiency: (entity as any).metabolismEfficiency ?? 1.0,
          perceptionRadius: (entity as any).perceptionRadius ?? 100
        }
      };
      // @ts-ignore
      const visual = getHerbivoreVisual(herbivoreEntity);
      // @ts-ignore
      herbivoreRenderer.render(this.ctx, herbivoreEntity, visual, x, y, time);
    }

    private drawCarnivoreEntity(x: number, y: number, scale: number, radius: number, healthColor: string, time: number, energyFactor: number) {
      if (!this.ctx) return;
      const isHunting = energyFactor < 0.5;
      const bob = Math.abs(Math.sin(time * 6)) * 2;
      const tailSway = Math.sin(time * 4) * 0.15;
      this.ctx.strokeStyle = healthColor;
      this.ctx.lineWidth = 3 * scale;
      this.ctx.lineCap = 'round';
      this.ctx.beginPath();
      this.ctx.moveTo(x - radius, y - bob);
      this.ctx.quadraticCurveTo(x - radius * 1.5, y - bob + tailSway * 15, x - radius * 2, y - bob + tailSway * 5);
      this.ctx.stroke();
      this.ctx.fillStyle = healthColor;
      this.ctx.beginPath();
      this.ctx.ellipse(x, y - bob, radius * 1.3, radius * 0.8, 0, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.beginPath();
      this.ctx.ellipse(x + radius * 0.8, y - bob - radius * 0.3, radius * 0.5, radius * 0.4, 0.2, 0, Math.PI * 2);
      this.ctx.fill();
      const eyeColor = isHunting ? '#ff4444' : '#333';
      this.ctx.fillStyle = isHunting ? '#ffcccc' : 'white';
      this.ctx.beginPath();
      this.ctx.ellipse(x + radius * 0.9, y - bob - radius * 0.35, radius * 0.15, radius * 0.12, 0, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.fillStyle = eyeColor;
      this.ctx.beginPath();
      this.ctx.arc(x + radius * 0.92, y - bob - radius * 0.35, radius * 0.07, 0, Math.PI * 2);
      this.ctx.fill();
      if (isHunting) {
        const glow = this.ctx.createRadialGradient(x + radius, y - bob, 0, x + radius, y - bob, radius * 3);
        glow.addColorStop(0, 'rgba(255, 100, 100, 0.2)');
        glow.addColorStop(1, 'transparent');
        this.ctx.fillStyle = glow;
        this.ctx.beginPath();
        this.ctx.arc(x + radius, y - bob, radius * 3, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    private drawFungusEntity(x: number, y: number, radius: number, baseColor: string, healthColor: string, time: number, healthFactor: number, energyFactor: number) {
      if (!this.ctx) return;
      const capY = y - radius * 1.2;
      const capWidth = radius * 2;
      this.ctx.fillStyle = '#f5f5f5';
      this.ctx.globalAlpha = 0.9;
      this.ctx.beginPath();
      this.ctx.moveTo(x - radius * 0.2, y);
      this.ctx.quadraticCurveTo(x - radius * 0.1, y - radius * 0.6, x, y - radius);
      this.ctx.quadraticCurveTo(x + radius * 0.1, y - radius * 0.6, x + radius * 0.2, y);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      this.ctx.fillStyle = baseColor;
      this.ctx.beginPath();
      this.ctx.arc(x, capY, capWidth * 0.5, Math.PI, 0);
      this.ctx.fill();
      this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      this.ctx.lineWidth = 0.5;
      for (let i = -2; i <= 2; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(x + i * radius * 0.15, capY + 2);
        this.ctx.lineTo(x + i * radius * 0.15, capY + radius * 0.3);
        this.ctx.stroke();
      }
      const isNight = Math.sin(time * 0.5) > 0;
      const fungusColor = COLORS.fungus;
      if (isNight || energyFactor > 0.6) {
        const glowIntensity = isNight ? 0.3 + Math.sin(time * 3) * 0.2 : (energyFactor - 0.6) * 0.5;
        const glow = this.ctx.createRadialGradient(x, capY, 0, x, capY, capWidth);
        glow.addColorStop(0, `hsla(${fungusColor.h}, 70%, 70%, ${glowIntensity})`);
        glow.addColorStop(1, 'transparent');
        this.ctx.fillStyle = glow;
        this.ctx.beginPath();
        this.ctx.arc(x, capY, capWidth, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    private drawNameTag(name: string, x: number, y: number, isSelected: boolean) {
      if (!this.ctx) return;
      this.ctx.font = isSelected ? 'bold 12px sans-serif' : '10px sans-serif';
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      const textWidth = this.ctx.measureText(name).width;
      const padding = 6;
      const boxWidth = textWidth + padding * 2;
      const boxHeight = 16;
      const boxX = x - boxWidth / 2;
      const boxY = y - boxHeight / 2;
      this.ctx.fillStyle = isSelected ? 'rgba(0, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.5)';
      this.ctx.beginPath();
      this.ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 4);
      this.ctx.fill();
      this.ctx.fillStyle = isSelected ? '#fff' : 'rgba(255, 255, 255, 0.9)';
      this.ctx.fillText(name, x, y);
    }
  }

  customElements.define('garden-canvas', GardenCanvas);
</script>
