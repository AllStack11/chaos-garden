---
/**
 * Garden Canvas Component
 *
 * Refactored to use Custom Elements for better encapsulation.
 */

export interface Props {
  width?: number;
  height?: number;
}

const {
  width = 1920,
  height = 1080,
} = Astro.props;
---

<garden-canvas data-width={width} data-height={height} class="block h-full w-full overflow-hidden">
  <canvas
    class="h-full w-full cursor-crosshair transition-opacity duration-1000"
  ></canvas>
</garden-canvas>

<script>
  import type { Entity } from '../env.d.ts';
  import {
    createBackgroundAnimationState,
    resizeBackgroundAnimationState,
    updateBackgroundAnimationState,
    type BackgroundAnimationState,
  } from '../lib/garden-canvas/background-effects/state.ts';
  import { renderBackgroundEffects } from '../lib/garden-canvas/background-effects/renderer.ts';
  import type { ViewportSize } from '../lib/garden-canvas/background-effects/types.ts';
  import { GardenEntityRenderer } from '../lib/garden-canvas/entity-rendering/renderer.ts';

  const COLORS = {
    plant: { h: 135, s: 40, l: 40 },
    herbivore: { h: 42, s: 60, l: 55 },
    carnivore: { h: 12, s: 50, l: 45 },
    fungus: { h: 280, s: 20, l: 65 },
  };

  class GardenCanvas extends HTMLElement {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private entities: Entity[] = [];
    private selectedEntity: Entity | null = null;
    private hoveredEntity: Entity | null = null;
    private mousePos = { x: 0, y: 0 };
    private targetMousePos = { x: 0, y: 0 };
    private animationId: number | null = null;
    private simWidth = 800;
    private simHeight = 600;
    private backgroundState: BackgroundAnimationState;
    private entityRenderer = new GardenEntityRenderer();

    private readonly handleWindowResize = () => this.handleResize();

    constructor() {
      super();
      this.canvas = this.querySelector('canvas')!;
      this.ctx = this.canvas.getContext('2d');
      this.backgroundState = createBackgroundAnimationState(this.getViewportSize());
      this.handleResize();
    }

    connectedCallback() {
      this.setupEventListeners();

      setTimeout(() => {
        this.handleResize();
        this.startAnimation();
      }, 0);
    }

    disconnectedCallback() {
      if (this.animationId) cancelAnimationFrame(this.animationId);
      this.removeEventListeners();
    }

    private setupEventListeners() {
      window.addEventListener('resize', this.handleWindowResize);
      this.canvas.addEventListener('mousemove', this.handleMouseMove);
      this.canvas.addEventListener('mouseleave', this.handleMouseLeave);
      this.canvas.addEventListener('click', this.handleCanvasClick);
    }

    private removeEventListeners() {
      window.removeEventListener('resize', this.handleWindowResize);
      this.canvas.removeEventListener('mousemove', this.handleMouseMove);
      this.canvas.removeEventListener('mouseleave', this.handleMouseLeave);
      this.canvas.removeEventListener('click', this.handleCanvasClick);
    }

    private readonly handleMouseMove = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      this.targetMousePos.x = event.clientX - rect.left;
      this.targetMousePos.y = event.clientY - rect.top;

      const worldPos = this.screenToWorld(this.targetMousePos.x, this.targetMousePos.y);
      this.hoveredEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);
    };

    private readonly handleMouseLeave = () => {
      this.hoveredEntity = null;
    };

    private readonly handleCanvasClick = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const worldPos = this.screenToWorld(x, y);
      const clickedEntity = this.findEntityAtPosition(worldPos.x, worldPos.y);

      this.dispatchEvent(new CustomEvent('entity-selected', {
        detail: clickedEntity,
        bubbles: true,
      }));
    };

    private handleResize() {
      const dpr = window.devicePixelRatio || 1;
      const viewport = this.getViewportSize();

      this.canvas.width = viewport.width * dpr;
      this.canvas.height = viewport.height * dpr;

      if (this.ctx) {
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      resizeBackgroundAnimationState(this.backgroundState, viewport);
    }

    private getViewportSize(): ViewportSize {
      const rect = this.getBoundingClientRect();
      return {
        width: rect.width || window.innerWidth,
        height: rect.height || window.innerHeight,
      };
    }

    private worldToScreen(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: x * scale + offsetX,
        y: y * scale + offsetY,
        scale,
      };
    }

    private screenToWorld(x: number, y: number) {
      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      const scale = Math.min(width / this.simWidth, height / this.simHeight) * 0.9;
      const offsetX = (width - this.simWidth * scale) / 2;
      const offsetY = (height - this.simHeight * scale) / 2;
      return {
        x: (x - offsetX) / scale,
        y: (y - offsetY) / scale,
      };
    }

    private findEntityAtPosition(x: number, y: number): Entity | null {
      for (const entity of this.entities) {
        const radius = this.calculateEntitySize(entity.energy) + 5;
        const distance = Math.sqrt(
          Math.pow(x - entity.position.x, 2) +
          Math.pow(y - entity.position.y, 2),
        );

        if (distance <= radius) return entity;
      }
      return null;
    }

    private calculateEntitySize(energy: number): number {
      return 4 + (energy / 20);
    }

    public updateState(entities: Entity[], selectedEntity: Entity | null) {
      this.entities = entities;
      this.selectedEntity = selectedEntity;
    }

    public getEntityCanvasPosition(entity: Entity) {
      return this.worldToScreen(entity.position.x, entity.position.y);
    }

    private startAnimation() {
      const loop = () => {
        this.update();
        this.render();
        this.animationId = requestAnimationFrame(loop);
      };
      this.animationId = requestAnimationFrame(loop);
    }

    private update() {
      const viewport = this.getViewportSize();
      updateBackgroundAnimationState(
        this.backgroundState,
        viewport,
        this.mousePos,
        this.targetMousePos,
        Date.now(),
      );
    }

    private render() {
      if (!this.ctx) return;

      const width = this.canvas.clientWidth || 800;
      const height = this.canvas.clientHeight || 600;
      this.ctx.clearRect(0, 0, width, height);

      renderBackgroundEffects({
        ctx: this.ctx,
        viewport: { width, height },
        mousePos: this.mousePos,
        spores: this.backgroundState.spores,
        shadows: this.backgroundState.shadows,
        glitchSparks: this.backgroundState.glitchSparks,
      });

      this.entityRenderer.renderEntities(this.ctx, this.entities, {
        selectedEntity: this.selectedEntity,
        hoveredEntity: this.hoveredEntity,
        worldToScreen: this.worldToScreen.bind(this),
        calculateEntitySize: this.calculateEntitySize.bind(this),
        colors: COLORS,
      });
    }
  }

  customElements.define('garden-canvas', GardenCanvas);
</script>
