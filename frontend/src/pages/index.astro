---
/**
 * Main Garden Page
 * 
 * Optimized with Custom Elements for robust state management.
 */

import Layout from '../layouts/Layout.astro';
import GardenCanvas from '../components/GardenCanvas.astro';
import StatsPanel from '../components/StatsPanel.astro';
import NarrativeTicker from '../components/NarrativeTicker.astro';
import JournalOverlay from '../components/JournalOverlay.astro';
import StatsOverlay from '../components/StatsOverlay.astro';

// API URL â€” required at build time
const API_URL = import.meta.env.PUBLIC_API_URL?.trim();
if (!API_URL) {
  throw new Error('Missing PUBLIC_API_URL. Set it in frontend/.env.production or your deploy environment before building.');
}
---

<Layout title="Chaos Garden ðŸŒ¿">
  <garden-app data-api-url={API_URL} class="block h-full w-full">
    <!-- Immersive Canvas -->
    <div class="absolute inset-0 z-0">
      <GardenCanvas />
    </div>

    <!-- UI Overlay Layer -->
    <div id="ui-overlay" class="pointer-events-none relative z-10 flex h-full w-full flex-col justify-between p-3 sm:p-4 md:p-8 transition-opacity duration-1000">
      
      <!-- Top Subtle Info -->
      <div class="flex items-start justify-between gap-4">
        <div class="group pointer-events-auto">
          <button
            type="button"
            data-journal-toggle
            class="flex flex-col opacity-50 transition-opacity hover:opacity-100 drop-shadow-sm text-left focus:outline-none focus-visible:ring-2 focus-visible:ring-garden-green-300/80 focus-visible:ring-offset-2 focus-visible:ring-offset-transparent rounded"
          >
            <h1 class="text-sm sm:text-base md:text-lg font-light tracking-[0.25em] sm:tracking-widest text-white uppercase">Chaos Garden</h1>
            <div id="system-status-container" class="mt-1 flex items-center space-x-2 text-[10px]">
              <div id="system-status-dot" class="h-1.5 w-1.5 rounded-full bg-white/40"></div>
              <span id="system-status-subtitle" class="font-mono text-white/60 tracking-tighter uppercase">Initializing...</span>
            </div>
          </button>
        </div>

        <div class="group pointer-events-auto">
          <div class="flex flex-col items-end opacity-50 transition-opacity hover:opacity-100 drop-shadow-sm">
             <div id="next-tick-countdown" class="font-mono text-lg sm:text-xl md:text-2xl font-light text-white tracking-widest">
                --:--
             </div>
             <div class="mt-1 text-[10px] text-white/40 uppercase tracking-[0.2em]">Next Evolution</div>
          </div>
        </div>
      </div>

      <!-- Center: Selection Tooltip (Floating Contextual) -->
      <div data-selection-info class="hidden pointer-events-none absolute transition-all duration-300">
        <div class="pointer-events-auto flex translate-y-0 sm:translate-y-8 flex-col items-center space-y-2 sm:space-y-3 rounded-2xl bg-garden-green-900/20 px-4 sm:px-6 py-3 sm:py-4 backdrop-blur-md border border-garden-green-500/10 shadow-2xl min-w-[150px] sm:min-w-[180px]">
          <div class="flex items-center space-x-3 sm:space-x-4">
             <div data-selection-icon class="text-xl sm:text-2xl"></div>
             <div class="flex flex-col">
               <div data-selection-name class="text-sm font-medium text-white/90 tracking-tight"></div>
               <div data-selection-species class="text-[8px] sm:text-[9px] text-white/40 uppercase tracking-widest"></div>
             </div>
          </div>
          
          <!-- Vital Indicators -->
          <div class="w-full space-y-2 pt-1 border-t border-white/5">
            <!-- Health Bar -->
            <div class="space-y-1">
              <div class="flex justify-between text-[8px] font-mono text-white/30 uppercase tracking-tighter">
                <span>Vigor</span>
                <span data-selection-health-text>--%</span>
              </div>
              <div class="w-full h-1 bg-white/5 rounded-full overflow-hidden">
                <div data-selection-health-bar class="h-full bg-green-400 transition-all duration-500"></div>
              </div>
            </div>
            <!-- Energy Bar -->
            <div class="space-y-1">
              <div class="flex justify-between text-[8px] font-mono text-white/30 uppercase tracking-tighter">
                <span>Essence</span>
                <span data-selection-energy-text>--%</span>
              </div>
              <div class="w-full h-1 bg-white/5 rounded-full overflow-hidden">
                <div data-selection-energy-bar class="h-full bg-yellow-400 transition-all duration-500"></div>
              </div>
            </div>
          </div>

          <div data-selection-stats class="text-[8px] sm:text-[9px] text-white/30 font-mono text-center pt-1"></div>
        </div>
      </div>

      <!-- Bottom: Environment Stats -->
      <div class="hidden sm:flex items-end justify-between">
        <div class="pointer-events-auto opacity-40 transition-opacity hover:opacity-100 drop-shadow-sm">
          <StatsPanel />
        </div>
        
        <div class="flex flex-col items-end space-y-6">
           <!-- Atmosphere Readouts -->
           <div class="flex space-x-6 opacity-40 transition-opacity hover:opacity-100 pointer-events-auto drop-shadow-sm">
             <div class="flex flex-col items-end">
                <span class="text-[9px] text-white/40 uppercase tracking-[0.2em]">Weather</span>
                <span id="env-weather" class="text-base text-white font-light italic">--</span>
             </div>
             <div class="flex flex-col items-end">
                <span class="text-[9px] text-white/40 uppercase tracking-[0.2em]">Atmosphere</span>
                <span id="env-temp" class="text-base text-white font-light italic">--Â°C</span>
             </div>
             <div class="flex flex-col items-end">
                <span class="text-[9px] text-white/40 uppercase tracking-[0.2em]">Luminance</span>
                <span id="env-sun" class="text-base text-white font-light italic">--%</span>
             </div>
           </div>

           <!-- Global Census (Ambient Footer) -->
           <div class="pointer-events-auto opacity-40 transition-opacity hover:opacity-100 flex flex-col items-end border-t border-white/10 pt-4 drop-shadow-sm">
              <span class="text-[8px] text-white/30 uppercase tracking-[0.4em]">Global Inhabitants</span>
              <div id="global-population" class="text-sm font-mono text-white mt-1 tracking-tighter">
                 -- <span class="text-[9px] opacity-40 ml-1 italic uppercase">Living</span>
              </div>
           </div>
        </div>
      </div>
    </div>

    <!-- Narrative overlays remain visible even when UI overlay fades -->
    <NarrativeTicker />
    <JournalOverlay />
    <StatsOverlay apiUrl={API_URL} />

    <!-- Loading State (Minimal Ambient) -->
    <div data-loading class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm transition-opacity duration-1000">
      <div class="flex flex-col items-center space-y-4">
        <div class="h-12 w-12 animate-spin rounded-full border-t-2 border-white/20"></div>
        <div class="text-xs font-light tracking-[0.3em] text-white/40 uppercase">Connecting...</div>
      </div>
    </div>
  </garden-app>
</Layout>

<script>
  import type { GardenState, Entity, SimulationEvent, HealthStatus } from '../env.d.ts';
  import { GardenService } from '../services/garden-service';

  class GardenApp extends HTMLElement {
    private gardenService: GardenService;
    private refreshInterval = 30000;
    private healthInterval = 10000;
    private gardenRefreshTimer: number | null = null;
    private healthCheckTimer: number | null = null;
    private countdownTimer: number | null = null;
    private uiTimeout: number | null = null;
    private readonly coarsePointerMediaQuery = window.matchMedia('(pointer: coarse)');
    private readonly mobileViewportMediaQuery = window.matchMedia('(max-width: 639px)');
    
    private state: {
      gardenState: GardenState | null;
      entities: Entity[];
      selectedEntity: Entity | null;
      recentEvents: SimulationEvent[];
      isLoading: boolean;
      health: HealthStatus | null;
      lastTickTime: Date | null;
      hasLoadedOnce: boolean;
      isStatsOverlayOpen: boolean;
      isJournalOverlayOpen: boolean;
    } = {
      gardenState: null,
      entities: [],
      selectedEntity: null,
      recentEvents: [],
      isLoading: true,
      health: null,
      lastTickTime: null,
      hasLoadedOnce: false,
      isStatsOverlayOpen: false,
      isJournalOverlayOpen: false,
    };

    constructor() {
      super();
      const apiUrl = this.dataset.apiUrl;
      if (!apiUrl) {
        throw new Error('Missing data-api-url on <garden-app>. Set PUBLIC_API_URL in your .env file.');
      }
      this.gardenService = GardenService.getInstance(apiUrl);
      console.log('[GardenApp] Constructor initialized');
      this.setupEventListeners();
    }

    connectedCallback() {
      console.log('[GardenApp] Connected to DOM');
      // Trigger load immediately
      this.loadGardenData();
      this.checkHealth();
      
      this.gardenRefreshTimer = window.setInterval(() => this.loadGardenData(), this.refreshInterval);
      this.healthCheckTimer = window.setInterval(() => this.checkHealth(), this.healthInterval);
      
      // Start countdown timer (every second)
      this.countdownTimer = window.setInterval(() => this.updateCountdown(), 1000);
    }

    disconnectedCallback() {
      if (this.gardenRefreshTimer) {
        clearInterval(this.gardenRefreshTimer);
        this.gardenRefreshTimer = null;
      }
      if (this.healthCheckTimer) {
        clearInterval(this.healthCheckTimer);
        this.healthCheckTimer = null;
      }
      if (this.countdownTimer) {
        clearInterval(this.countdownTimer);
        this.countdownTimer = null;
      }
      if (this.uiTimeout) {
        clearTimeout(this.uiTimeout);
        this.uiTimeout = null;
      }
      this.removeEventListener('entity-selected', this.handleEntitySelected as EventListener);
      this.removeEventListener('stats-overlay-open-requested', this.handleStatsOverlayOpen as EventListener);
      this.removeEventListener('stats-overlay-closed', this.handleStatsOverlayClosed as EventListener);
      this.removeEventListener('journal-overlay-open-requested', this.handleJournalOverlayOpen as EventListener);
      this.removeEventListener('journal-overlay-closed', this.handleJournalOverlayClosed as EventListener);
      const journalToggle = this.querySelector('[data-journal-toggle]');
      journalToggle?.removeEventListener('click', this.handleJournalToggle);
      window.removeEventListener('mousemove', this.resetUIOverlayOpacity);
      window.removeEventListener('click', this.resetUIOverlayOpacity);
      window.removeEventListener('pointerdown', this.resetUIOverlayOpacity);
      window.removeEventListener('resize', this.handleViewportModeChange);
      this.coarsePointerMediaQuery.removeEventListener('change', this.handleViewportModeChange);
      this.mobileViewportMediaQuery.removeEventListener('change', this.handleViewportModeChange);
    }

    private readonly handleEntitySelected = (event: Event) => {
      const entitySelectedEvent = event as CustomEvent<Entity | null>;
      this.state.selectedEntity = entitySelectedEvent.detail;
      this.updateUI();
    };

    private readonly handleJournalToggle = () => {
      this.dispatchEvent(new CustomEvent('journal-overlay-open-requested', { bubbles: true, composed: true }));
    };

    private readonly resetUIOverlayOpacity = () => {
      const overlay = this.querySelector('#ui-overlay');
      if (overlay) overlay.classList.remove('opacity-0');
      if (this.uiTimeout) {
        clearTimeout(this.uiTimeout);
        this.uiTimeout = null;
      }

      if (this.state.isStatsOverlayOpen || this.state.isJournalOverlayOpen) {
        return;
      }

      if (this.isMobileUiMode()) {
        return;
      }

      this.uiTimeout = window.setTimeout(() => {
        if (overlay && !this.state.selectedEntity) overlay.classList.add('opacity-0');
      }, 5000);
    };

    private readonly handleViewportModeChange = () => {
      this.resetUIOverlayOpacity();
      if (this.state.selectedEntity) this.updateUI();
    };

    private isMobileUiMode(): boolean {
      return this.coarsePointerMediaQuery.matches || this.mobileViewportMediaQuery.matches;
    }

    private setupEventListeners() {
      this.addEventListener('entity-selected', this.handleEntitySelected as EventListener);
      this.addEventListener('stats-overlay-open-requested', this.handleStatsOverlayOpen as EventListener);
      this.addEventListener('stats-overlay-closed', this.handleStatsOverlayClosed as EventListener);
      this.addEventListener('journal-overlay-open-requested', this.handleJournalOverlayOpen as EventListener);
      this.addEventListener('journal-overlay-closed', this.handleJournalOverlayClosed as EventListener);
      const journalToggle = this.querySelector('[data-journal-toggle]');
      journalToggle?.addEventListener('click', this.handleJournalToggle);
      window.addEventListener('mousemove', this.resetUIOverlayOpacity);
      window.addEventListener('click', this.resetUIOverlayOpacity);
      window.addEventListener('pointerdown', this.resetUIOverlayOpacity);
      window.addEventListener('resize', this.handleViewportModeChange);
      this.coarsePointerMediaQuery.addEventListener('change', this.handleViewportModeChange);
      this.mobileViewportMediaQuery.addEventListener('change', this.handleViewportModeChange);
      this.resetUIOverlayOpacity();
    }

    private readonly handleStatsOverlayOpen = () => {
      const overlay = this.querySelector('stats-overlay') as HTMLElement & { openOverlay?: () => void };
      if (overlay && typeof overlay.openOverlay === 'function') {
        overlay.openOverlay();
        this.state.isStatsOverlayOpen = true;
        const overlayLayer = this.querySelector('#ui-overlay');
        if (overlayLayer) {
          overlayLayer.classList.add('opacity-0');
        }
      }
    };

    private readonly handleStatsOverlayClosed = () => {
      this.state.isStatsOverlayOpen = false;
      const overlayLayer = this.querySelector('#ui-overlay');
      if (overlayLayer) {
        overlayLayer.classList.remove('opacity-0');
      }
      this.resetUIOverlayOpacity();
    };

    private readonly handleJournalOverlayOpen = () => {
      const overlay = this.querySelector('journal-overlay') as HTMLElement & { openOverlay?: () => void; setEvents?: (events: SimulationEvent[]) => void };
      if (overlay) {
        if (typeof overlay.setEvents === 'function') {
          overlay.setEvents(this.state.recentEvents);
        }
        if (typeof overlay.openOverlay === 'function') {
          overlay.openOverlay();
          this.state.isJournalOverlayOpen = true;
          const overlayLayer = this.querySelector('#ui-overlay');
          if (overlayLayer) {
            overlayLayer.classList.add('opacity-0');
          }
        }
      }
    };

    private readonly handleJournalOverlayClosed = () => {
      this.state.isJournalOverlayOpen = false;
      const overlayLayer = this.querySelector('#ui-overlay');
      if (overlayLayer) {
        overlayLayer.classList.remove('opacity-0');
      }
      this.resetUIOverlayOpacity();
    };

    private async loadGardenData() {
      console.log('[GardenApp] loadGardenData starting');
      try {
        if (!this.state.hasLoadedOnce) {
          this.state.isLoading = true;
          this.updateUI();
        }

        const data = await this.gardenService.fetchGardenData();

        if (data) {
          console.log('[GardenApp] Data received:', data);
          const selectedEntityId = this.state.selectedEntity?.id;
          this.state.gardenState = data.gardenState;
          this.state.entities = data.entities;
          this.state.recentEvents = data.events;
          this.state.selectedEntity = selectedEntityId
            ? this.state.entities.find((entity) => entity.id === selectedEntityId) ?? null
            : null;
          
          if (data.gardenState.timestamp) {
            const newTickTime = new Date(data.gardenState.timestamp);
            if (!this.state.lastTickTime || newTickTime > this.state.lastTickTime) {
              this.state.lastTickTime = newTickTime;
            }
          }
          this.state.hasLoadedOnce = true;
        } else {
          console.warn('[GardenApp] No data returned from service');
        }
      } catch (error) {
        console.error('[GardenApp] Failed to load garden:', error);
        this.showNotification('Failed to load garden data. Please try again.', 'error');
      } finally {
        this.state.isLoading = false;
        this.updateUI();
        console.log('[GardenApp] loadGardenData finished');
      }
    }

    private updateUI() {
      // Update Global Population
      const popEl = document.getElementById('global-population');
      if (popEl && this.state.gardenState) {
        popEl.innerHTML = `${this.state.gardenState.populationSummary.totalLiving} <span class="text-[9px] opacity-40 ml-1 uppercase">Living</span>`;
      }

      // Update canvas
      const canvas = this.querySelector('garden-canvas') as any;
      if (canvas && typeof canvas.updateState === 'function') {
        canvas.updateState(
          this.state.entities,
          this.state.selectedEntity,
          this.state.gardenState,
          this.state.recentEvents,
        );
      } else if (canvas) {
        console.warn('[GardenApp] garden-canvas found but updateState is not yet available');
      }

      // Update Narrative Ticker
      const narrativeTicker = this.querySelector('narrative-ticker') as HTMLElement & { updateNarrativeEvents?: (events: SimulationEvent[]) => void };
      if (narrativeTicker && typeof narrativeTicker.updateNarrativeEvents === 'function') {
        narrativeTicker.updateNarrativeEvents(this.state.recentEvents);
      }

      // Update Journal Overlay feed
      const journalOverlay = this.querySelector('journal-overlay') as HTMLElement & { setEvents?: (events: SimulationEvent[]) => void };
      if (journalOverlay && typeof journalOverlay.setEvents === 'function') {
        journalOverlay.setEvents(this.state.recentEvents);
      }

      // Update Loading
      const loading = this.querySelector('[data-loading]') as HTMLElement;
      if (loading) loading.classList.toggle('hidden', !this.state.isLoading);

      // Update Selection Info (Tooltip)
      const selectionInfo = this.querySelector('[data-selection-info]') as HTMLElement;
      if (selectionInfo) {
        selectionInfo.classList.toggle('hidden', !this.state.selectedEntity);
        if (this.state.selectedEntity) {
          const entity = this.state.selectedEntity;
          const nameEl = this.querySelector('[data-selection-name]')!;
          const speciesEl = this.querySelector('[data-selection-species]')!;
          const statsEl = this.querySelector('[data-selection-stats]')!;
          const iconEl = this.querySelector('[data-selection-icon]')!;
          
          // Vital bar elements
          const healthBar = this.querySelector('[data-selection-health-bar]') as HTMLElement;
          const healthText = this.querySelector('[data-selection-health-text]')!;
          const energyBar = this.querySelector('[data-selection-energy-bar]') as HTMLElement;
          const energyText = this.querySelector('[data-selection-energy-text]')!;
          
          nameEl.textContent = entity.name;
          speciesEl.textContent = entity.species;
          statsEl.textContent = `Age: ${entity.age} Evolution Ticks`;
          
          const icons = {
            plant: 'ðŸŒ¿',
            herbivore: 'ðŸ¦Œ',
            carnivore: 'ðŸº',
            fungus: 'ðŸ„'
          };
          iconEl.textContent = icons[entity.type] || 'â“';

          // Update Vitals
          if (healthBar) {
            healthBar.style.width = `${entity.health}%`;
            healthBar.className = `h-full transition-all duration-500 ${
              entity.health > 60 ? 'bg-green-400' : entity.health > 30 ? 'bg-yellow-400' : 'bg-red-400'
            }`;
          }
          healthText.textContent = `${Math.round(entity.health)}%`;

          if (energyBar) {
            energyBar.style.width = `${entity.energy}%`;
          }
          energyText.textContent = `${Math.round(entity.energy)}%`;

          // Update tooltip position if canvas knows it
          if (canvas && typeof canvas.getEntityCanvasPosition === 'function') {
             const pos = canvas.getEntityCanvasPosition(this.state.selectedEntity);
             if (pos) {
                this.positionSelectionPanel(selectionInfo, pos);
             }
          }
        }
      }

      // Update Stats Panel (via event or direct ref)
      const statsPanel = this.querySelector('stats-panel') as any;
      if (statsPanel && this.state.gardenState) {
        statsPanel.updateState(this.state.gardenState);
      }

      // Update Last Update Time
      const lastUpdate = this.querySelector('[data-last-update]') as HTMLElement;
      if (lastUpdate) lastUpdate.textContent = new Date().toLocaleTimeString();

      this.updateStatusUI();
    }

    private positionSelectionPanel(selectionInfo: HTMLElement, pos: { x: number; y: number }) {
      const margin = 12;

      if (this.isMobileUiMode()) {
        selectionInfo.style.left = '50%';
        selectionInfo.style.right = 'auto';
        selectionInfo.style.top = 'auto';
        selectionInfo.style.bottom = `calc(${margin}px + env(safe-area-inset-bottom))`;
        selectionInfo.style.transform = 'translateX(-50%)';
        return;
      }

      selectionInfo.style.transform = '';
      selectionInfo.style.right = '';
      selectionInfo.style.bottom = '';

      // Place near entity first to measure size
      selectionInfo.style.left = `${pos.x}px`;
      selectionInfo.style.top = `${pos.y}px`;

      requestAnimationFrame(() => {
        const rect = selectionInfo.getBoundingClientRect();

        // Center horizontally
        const desiredLeft = pos.x - rect.width / 2;
        const clampedLeft = Math.min(
          Math.max(margin, desiredLeft),
          Math.max(margin, window.innerWidth - rect.width - margin),
        );

        // Prefer placing below; if not enough room, place above
        const spaceBelow = window.innerHeight - (pos.y + margin);
        const placeAbove = spaceBelow < rect.height + margin;
        const desiredTop = placeAbove ? pos.y - rect.height - margin : pos.y + margin;
        const clampedTop = Math.min(
          Math.max(margin, desiredTop),
          Math.max(margin, window.innerHeight - rect.height - margin),
        );

        selectionInfo.style.left = `${clampedLeft}px`;
        selectionInfo.style.top = `${clampedTop}px`;
      });
    }

    private async checkHealth() {
      try {
        const health = await this.gardenService.checkHealth();
        this.state.health = health;
        if (health?.gardenState?.timestamp) {
           const newTickTime = new Date(health.gardenState.timestamp);
           if (!this.state.lastTickTime || newTickTime > this.state.lastTickTime) {
             this.state.lastTickTime = newTickTime;
           }
        }
      } catch (error) {
        console.error('[GardenApp] Health check failed:', error);
        this.state.health = { 
          status: 'unhealthy', 
          timestamp: new Date().toISOString(),
          gardenState: null,
          config: { tickIntervalMinutes: 15 }
        };
      } finally {
        this.updateStatusUI();
      }
    }

    private updateStatusUI() {
      const isHealthy = this.state.health?.status === 'healthy';
      
      const dot = document.getElementById('system-status-dot');
      const subtitle = document.getElementById('system-status-subtitle');

      if (dot && subtitle) {
        if (isHealthy) {
          dot.className = 'h-1.5 w-1.5 rounded-full bg-green-500 shadow-[0_0_5px_rgba(34,197,94,0.5)] animate-pulse';
          const currentTick = this.state.health?.gardenState?.tick ?? this.state.gardenState?.tick;
          subtitle.textContent = `TICK #${currentTick ?? '?'}`;
        } else {
          dot.className = 'h-1.5 w-1.5 rounded-full bg-red-500';
          subtitle.textContent = 'SYSTEM DISCONNECTED';
        }
      }

      // Update Env Stats
      const tempEl = document.getElementById('env-temp');
      const sunEl = document.getElementById('env-sun');
      const weatherEl = document.getElementById('env-weather');
      if (tempEl && this.state.gardenState) {
        tempEl.textContent = `${Math.round(this.state.gardenState.environment.temperature)}Â°C`;
      }
      if (sunEl && this.state.gardenState) {
        sunEl.textContent = `${Math.round(this.state.gardenState.environment.sunlight * 100)}%`;
      }
      if (weatherEl && this.state.gardenState) {
        const weatherLabels: Record<string, string> = {
          CLEAR: 'Clear',
          OVERCAST: 'Overcast',
          RAIN: 'Rain',
          STORM: 'Storm',
          DROUGHT: 'Drought',
          FOG: 'Fog',
        };
        const currentWeather = this.state.gardenState.environment.weatherState?.currentState;
        weatherEl.textContent = currentWeather ? (weatherLabels[currentWeather] ?? currentWeather) : '--';
      }
    }

    private updateCountdown() {
      if (!this.state.lastTickTime) return;

      const countdownEl = document.getElementById('next-tick-countdown');
      if (!countdownEl) return;

      const intervalMs = (this.state.health?.config?.tickIntervalMinutes || 15) * 60 * 1000;
      const gracePeriodMs = 60000; // 1 minute grace period before showing "Evolving..."
      
      const now = new Date().getTime();
      const lastTickMs = this.state.lastTickTime.getTime();
      const nextTickMs = lastTickMs + intervalMs;
      
      let remainingMs = nextTickMs - now;
      
      if (remainingMs < -gracePeriodMs) {
        countdownEl.textContent = "Evolving...";
        countdownEl.classList.add('animate-pulse');
        return;
      }

      countdownEl.classList.remove('animate-pulse');

      if (remainingMs < 0) {
        countdownEl.textContent = "00:00";
        return;
      }
      
      const minutes = Math.floor(remainingMs / 60000);
      const seconds = Math.floor((remainingMs % 60000) / 1000);
      
      countdownEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    private showNotification(message: string, type: 'success' | 'error' | 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg border transition-opacity duration-500 ${
        type === 'success' ? 'bg-green-50 border-green-200 text-green-800' :
        type === 'error' ? 'bg-red-50 border-red-200 text-red-800' :
        'bg-blue-50 border-blue-200 text-blue-800'
      }`;
      notification.textContent = message;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 500);
      }, 3000);
    }
  }

  if (!customElements.get('garden-app')) {
    customElements.define('garden-app', GardenApp);
  }
</script>
